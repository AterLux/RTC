/*
 * rtc.h
 *
 * Подсистема учёта реального времени
 *
 * Author: Погребняк Дмитрий (Pogrebnyak Dmitry, http://aterlux.ru/)
 */ 


#ifndef RTC_H_
#define RTC_H_

#include <avr/io.h>


#define SECONDS_PER_MINUTE 60
#define MINUTES_PER_HOUR 60
#define HOURS_PER_DAY 24
#define SECONDS_PER_HOUR 3600
#define SECONDS_PER_DAY 86400UL

#define SECONDS_PER_NONLEAP_YEAR (SECONDS_PER_DAY * 365)
#define SECONDS_PER_LEAP_YEAR (SECONDS_PER_DAY * 366)

// Адрес в EEPROM значения калибровки хода. Значение хранится как знаковое целое, младшим байтом вперёд, в побитно-инвертированном виде
#define EEADDR_RTC_CALIBRATION 0 

// Адрес в EEPROM значение температурного коэффициента. При значении 0xFF загружается DEFAULT_THERMAL_KOEF_MIL
#define EEADDR_RTC_THERMAL_KOEF 2

// Коэффициент температурной коррекции по-умолчанию, в тысячных долях ppm/°C²
#define DEFAULT_THERMAL_KOEF_MIL 40

// Температура (в 1/16 °C) соответствующая вершине параболы на частотно-температурной характеристике кристалла, типично 25°C
#define RTC_TURNOVER_TEMPERATURE_16 (25 * 16)

typedef struct {
  uint8_t second, minute, hour;
  uint8_t day, month, year;
} RtcValues;

// Переменная, увеличивающаяся на 1 раз в секунду или при обновлении значений часов реального времени
extern volatile uint8_t seconds_counter;

/* Инициализирует часы реального времени, настраивает и запускает таймер */
void rtc_init();

/* Возвращает не 0, если таймер 2 уже работает в асинхронном режиме */
uint8_t rtc_is_running();

/* Отстраняет подсистему RTC от учёта времени: отключает прерывание часов, кодирует текущее время в виде 32-битного целого */
uint32_t rtc_detach();

/* Производит восстановление работы подсистемы RTC для учёта времени, восстанавливает показания часов и работу таймера с учётом флага переполнения */
uint8_t rtc_restore(uint32_t time);

/* Ожидает готовности асихнронных регистров таймера 2 */
void rtc_wait();

/* Кодирует показания часов из структуры в виде одного 32-битного целого, означающего количество секунд, прошедших с 1.1.2000 00:00:00 */
uint32_t rtc_to_uint32(const RtcValues * p_rtc_values);

/* Декодирует время из  32-битного целого, и заполняет поля структуры */
void uint32_to_rtc(uint32_t value, RtcValues * p_rtc);

/* Получает значение текущего времени. 
 * Если with_sub_time не равно нулю, то результатом функции будет дробная часть секунды (в 1/256 долях) на момент получения времени */
uint8_t rtc_latch(RtcValues * p_rtc, uint8_t with_sub_time);

/* Возвращает текущее значение долей секунды (с учётом возможной произошедшей компенсации) */
uint8_t rtc_get_subtime();


/* Обновляет текущие показания часов реального времени 
 * with_sub_time - если не 0, то обновляется и дробная часть секунды
 * sub_time - дробная часть секунды (в 1/256 долях). */
void rtc_update(const RtcValues * p_new_time, uint8_t with_sub_time, uint8_t sub_time);

/* Возвращает день недели на указанную дату
 * 1 - понедельник, 7 - воскресенье, 0 - выход за пределы */
uint8_t day_of_week(uint8_t d, uint8_t m, uint8_t y);

/* Возвращает количество дней в месяце, с учётом февралей високосных лет */
uint8_t days_in_month(uint8_t month, uint8_t year);

/* Возвращает текущее заданное значение компенсации хода */
int16_t rtc_get_calibration();

/* Устанавливает новое значение компенсации хода */
void rtc_set_calibration(int16_t calibration);

/* Обновляет термокомпенсацию в соответствии с переданным значением температуры. 
 * Температура в 1/16 долях градуса цельсия, т.е. значение 400 соответствует +25°C */
void rtc_update_temperature(int16_t temperature16);

/* Устанавливает новое значение температурного коэффциента термокомпенсации.
 * Параметр указывает значение коэффициента в -1/1000 долях ppm (т.е. в миллиардных долях) на градус цельсия в квадрате.
 * Температура высчитывается как разница между текущей температурой и RTC_TURNOVER_TEMPERATURE_16 (25°C)
 * Значение задаётся неотрицательным числом от 0 до 254, Например, значение 45 обозначает коэффициент 0.045 ppm/°C² */
void rtc_set_thermal_koef(uint8_t milppm_per_c2);

/* Возвращает текущее установленное значение температурного коээфициента (в 1/100 долях /°C²) */
uint8_t rtc_get_thermal_koef();

/* Возвращает текущее вычисленное значение температурной компенсации */
int16_t rtc_get_thermal_compenstaion();

/* Возвращает текущее используемое значение компенсации */
int16_t rtc_get_total_compensation();


#endif /* RTC_H_ */